require "sequitur"

class Grammar
  attr_accessor :rules, :start
  def initialize()
    # string
    @start = nil
    # string -> (GSymbol array) map
    @rules = {}
  end
  def addRule(left,right)
    @rules[left] = right
  end
  # replaces all occurrences of (varold: string) with (varnew: string) and removes
  # rule for varold
  def replaceVar(varold,varnew)
    raise unless (@rules.has_key? varold and @rules.has_key? varnew)
    if(varold == @start) then @start = varnew end
    symnew = GSymbol.new(true,varnew)
    @rules.delete(varold)
    @rules.each do |curLeft,curRight|
      curRight.map! do |sym|
        if (sym.isVar && sym.token == varold)
          symnew
        else
          sym
        end
      end
    end
  end
  # returns the array of terminal symbols generated by curVar : string
  def expandVar(curVar)
    raise unless (curVar.class == String)
    curSeq = @rules[curVar]
    nextVarInd = curSeq.index {|sym| sym.isVar}
    # recursively replace variables until only terminals left
    until nextVarInd == nil
      #nextVar : string
      nextVar = curSeq[nextVarInd].token
      repText = expandVar(nextVar)
      curSeq = curSeq.map do |sym|
        if (sym.isVar && sym.token == nextVar)
          next repText
        else
          next sym
        end
      end
      curSeq = curSeq.flatten
      nextVarInd = curSeq.index {|sym| sym.isVar}
    end
    return curSeq
  end
  def to_s
    out = "Start: "+@start.to_s+"\n"
    @rules.each do |curLeft,curRight|
      out += (curLeft)+":>"+(curRight.to_s)+"\n"
    end
    return out
  end
end

class GSymbol
  attr_accessor :token, :isVar
  def initialize(isVar,token)
    @isVar = isVar
    @token = token
  end
  def to_s
    return @token
  end
  def ==(symbol2)
    raise unless @isVar == symbol2.isVar
    return (@token == symbol2.token and @isVar == symbol2.isVar)
  end
end

# string sequence -> symbol list for debugging purposes
def createSymList(strSeq)
  outArr = []
  strSeq.split("").each do |c|
    if (c.upcase == c)
      outArr << GSymbol.new(true,c)
    else
      outArr << GSymbol.new(false,c)
    end
  end
  return outArr
end


# Converts from the linked-list CFG format used in sequitur to
# the array + dictionary CFG format here. Algorithm stolen from
# puts_grammar

def convert_seq(seqGrammar)
  newGramm = Grammar.new()

  curRules = [seqGrammar]
  nonterminals = {"*" => true}
  newGramm.start = "*"
  curRules.each do |rule|
    newVar = rule.token
    newSeq = []
    nextsym = rule.next
    until nextsym.is_head? do
      if not nextsym.rule.nil?
        curRules << nextsym.rule if not nonterminals[nextsym.token]
        nonterminals[nextsym.token] = true
        newSeq << GSymbol.new(true,nextsym.token)
      else
        newSeq << GSymbol.new(false,nextsym.token)
      end
      nextsym = nextsym.next
    end
    newGramm.addRule(newVar,newSeq)
  end
  return newGramm
end

str = "aactgaacatgagagacatagagacag"
gramm1 = Sequitur.new(str).run
myGrammar = convert_seq(gramm1)
puts myGrammar.expandVar("*").to_s
myGrammar.replaceVar("E","D")
puts myGrammar.to_s
